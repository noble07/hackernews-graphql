import { extendType, idArg, nonNull, objectType, stringArg } from 'nexus'
import { NexusGenObjects } from '../../nexus-typegen'

export const Link = objectType({
  name: 'Link', // 1. The name option defines the name of the type
  definition(t) { // 2. Inside the definition, you can add different fields that get added to the type
    t.nonNull.int('id'), // 3. This adds a field named id of type Int
    t.nonNull.string('description'), // 4. This adds a field named description of type String
    t.nonNull.string('url') // 5. This adds a field named url of type String
  }
})


// 1. The links variable is used to store the links at runtime. For now, everything is stored only in-memory rather than being persisted in a database. 
// Youâ€™re also using the Link interface generated by Nexus to define the type of the links variable as an array of Link objects.
let links: NexusGenObjects['Link'][] = [
  {
    id: 1,
    url: 'https://www.howtographql.com',
    description: 'Fullstack tutorial for GraphQL'
  },
  {
    id: 2,
    url: 'graphql.org',
    description: 'GraphQL official website'
  }
]

export const LinkQuery = extendType({ // 2. You are extending the Query root type and adding a new root field to it called feed.
  type: 'Query',
  definition(t) {
    t.nonNull.list.nonNull.field('feed', { // 3. You define the return type of the feed query as a not nullable array of link type objects (In the SDL the return type will look like this: [Link!]!).
      type: 'Link',
      // 4. resolve is the name of the resolver function of the feed query. A resolver is the implementation for a GraphQL field.
      // Every field on each type (including the root types) has a resolver function which is executed to get the return value when fetching that type. For now, our resolver implementation is very simple, it just returns the links array.
      // The resolve function has four arguments, parent, args, context and info. We will get to these later.
      resolve(parent, args, context) {
        return links
      }
    })
    t.field('link', {
      type: 'Link',
      description: 'Fetch a single link by its `id`',
      args: {
       id: nonNull(idArg())
      },
      resolve(parent, args, context) {
        const { id } = args
        return links.find(link => link.id === parseInt(id)) || null
      }
    })
  }
})

export const LinkMutation = extendType({ // 1: Youâ€™re extending the Mutation type to add a new root field. You did something similar in the last chapter with the Query type.
  type: 'Mutation',
  definition(t) {
    t.nonNull.field('post', { // 2: The name of the mutation is defined as post and it returns a (non nullable) link object.
      type: 'Link',
      description: 'Update a link',
      args: { // 3: Here you define the arguments to your mutation. You can pass arguments to your GraphQL API endpoints (just like in REST). 
        //In this case, the two arguments you need to pass are description and url. Both arguments mandatory (hence the nonNull()) because both are needed to create a new link.
        description: nonNull(stringArg()),
        url: nonNull(stringArg())
      },
      resolve(parent, args, context) {
        const { description, url } = args // 4: Youâ€™re now using the second argument thatâ€™s passed into all resolver functions: args. Any guesses what itâ€™s used for? â€¦ Correct! 
        //ğŸ’¡ It carries the arguments for the operation â€“ in this case the url and description of the link to be created.

        let idCount = links.length + 1
        const link = {
          id: idCount,
          description: description,
          url: url
        }

        links.push(link)
        return link
      }
    })
    t.nonNull.field('updateLink', {
      type: 'Link',
      description: 'Update a link',
      args: {
        id: nonNull(idArg()),
        url: stringArg(),
        description: stringArg()
      },
      resolve(parent, args, context) {
        const { id, url = '', description = '' } = args
        const indexLink = links.findIndex(link => link.id === parseInt(id))

        links[indexLink] = {...links[indexLink], url, description} as NexusGenObjects['Link']

        return links[indexLink]
      }
    })
    t.nonNull.field('deleteLink', {
      type: 'Link',
      description: 'Delete a link',
      args: {
        id: nonNull(idArg())
      },
      resolve(parent, args, context) {
        const { id } = args

        const indexLink = links.findIndex(link => link.id === parseInt(id))
        const deletedLink = links[indexLink]

        links = links.filter(link => link.id !== parseInt(id))

        return deletedLink
      }
    })
  }
})